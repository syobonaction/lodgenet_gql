package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"netreality.world/m/graph/datasources"
	"netreality.world/m/graph/model"
)

// CurrentWeather is the resolver for the currentWeather field.
func (r *queryResolver) CurrentWeather(ctx context.Context, lat string, lon string) (*model.CurrentWeather, error) {
	d := &datasources.CurrentWeather{}
	err := datasources.GetCurrentWeather(d, lat, lon)

	if err != nil {
		return nil, err
	} else {
		w := []*model.Weather{}
		caser := cases.Title(language.AmericanEnglish)

		for _, s := range d.Weather {
			e := &model.Weather{
				ID:          s.Id,
				Type:        s.Main,
				Description: caser.String(s.Description),
				Icon:        s.Icon,
			}

			w = append(w, e)
		}

		a := &model.Atmosphere{
			Temperature: &model.Temperature{
				Real:      d.Main.Temp,
				Min:       d.Main.Temp_min,
				Max:       d.Main.Temp_max,
				Feelslike: d.Main.Feels_like,
			},
			Pressure: &d.Main.Pressure,
			Humidity: &d.Main.Humidity,
		}

		c := &model.Conditions{
			Wind: &model.Wind{
				Speed:  d.Wind.Speed,
				Degree: d.Wind.Deg,
				Gust:   d.Wind.Gust,
			},
			Sunrise: d.Sys.Sunrise,
			Sunset:  d.Sys.Sunset,
		}

		m := &model.CurrentWeather{
			Weather:    w,
			Atmosphere: a,
			Conditions: c,
		}

		return m, nil
	}
}

// Forecast is the resolver for the forecast field.
func (r *queryResolver) Forecast(ctx context.Context, lat string, lon string) ([]*model.Forecast, error) {
	d := &datasources.Forecast{}
	err := datasources.GetForecast(d, lat, lon)

	if err != nil {
		return nil, err
	} else {
		m := []*model.Forecast{}

		for _, s := range d.List {
			w := []*model.Weather{}
			caser := cases.Title(language.AmericanEnglish)

			for _, s := range s.Weather {
				e := &model.Weather{
					ID:          s.Id,
					Type:        s.Main,
					Description: caser.String(s.Description),
					Icon:        s.Icon,
				}

				w = append(w, e)
			}

			v := &model.Forecast{
				Time: &model.Time{
					AsInt:    s.Dt,
					AsString: s.Dt_txt,
				},
				Weather: w,
				Atmosphere: &model.Atmosphere{
					Temperature: &model.Temperature{
						Real:      s.Main.Temp,
						Min:       s.Main.Temp_min,
						Max:       s.Main.Temp_max,
						Feelslike: s.Main.Feels_like,
					},
					Pressure: &s.Main.Pressure,
					Humidity: &s.Main.Humidity,
				},
				Conditions: &model.Conditions{
					Wind: &model.Wind{
						Speed:  s.Wind.Speed,
						Degree: s.Wind.Deg,
						Gust:   s.Wind.Gust,
					},
				},
			}

			m = append(m, v)
		}

		return m, nil
	}
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
